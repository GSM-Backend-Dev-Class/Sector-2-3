# Session
## 정의
- 서버에서 사용자의 로그인 상태를 유지하는 방식
- 사용자가 로그인하면 서버에서 세션 ID를 생성하고 클라이언트에 저장
- 이후 요청마다 세션 ID를 서버에 보내어 인증
## 저장 방법
총 3가지 방법으로 데이터를 저장시킨다(서버 설정마다 다름)
- 메모리
- 하드디스크
- 데이터베이스
## 특징
- 모든 정보를 **서버에 저장**함
- 또한 모든 정보를 저장하고 있기에 **추방,변경등 직접 제어가 가능**함
## 단점
- 저장 위치는 위와같이 저장이 되는데 **보안이 높을수록 요청 시간이 길어져** 오래 걸린다
- 하지만 모든 정보를 저장하기 때문에 **돈이 많이 든다**
# JWT
Authentication = 인증(저는 이런 사람 입니다)  
Authorization = 인가(아 너는 그런 사람이구나 넘어가)
## 특징
- **서버에 저장 하지않고** 그저 토큰이 유호 한지 안한지만 확인을 한다
- 토큰은 마침표를 기준으로 **3가지로 나뉜다**(xxxxxxxx.yyyyyyyy.zzzzzzz)
- 위기준 **x는 header(헤더),y는 payload(페이로드),z는 verify signature(서명)**
- 페이로드에는 토큰이 **언제부터 어디까지,누구에게,무엇을 공개할지 등**의 데이터가 담겨있다=이것을 **클레임(Claim)**이라고 부른다.
- 헤더에는 2가지 정보가 들어가는 데 하나는 **type으로 JWT고정**이다
나머지 하나는 alg(알고리즘) 3번 서명을 만드는데 사용되는 **알고리즘울 저장**한다. 여러 암호와 방식을 지정하여 사용가능(ex:HS256(비밀 키를 알고 있는 경우만 서명을 확인),RS256:개인 키로 서명하고 공개 키로 검증)
- 서명은 **헤더와 페이로드를 모두 암호화** 하면 나오게 된다
## 단점
- 하지만 서버는 저장한것이 없기 때문에 **제어가 불가능**함
- 또한 누군가가 토큰을 가져가면 **그것을 방어할 수단**또한 사라짐
## 보완(ex)
- 만료시간을 짧게 만든 access 토큰과 만료시간을 길게 잡은(약 2주)를 잡아놓은 refresh 토큰을 준다
- refresh 토큰은 데이터베이스에 저장
- 유저는 access 토큰이 만료되면 refresh 토큰을 보냄
- 서버는 그걸 데이터베이스와 대조후 새 access 토큰을 보내는식
# OAuth
## 정의
- 타사 서비스의 인증을 위임하는 방식
- Google, Facebook, GitHub 등의 계정을 활용하여 로그인 가능
- 일반적으로 OAuth 2.0을 사용
## 특징
- Access Token 발급을 통해 API 접근 권한 관리
- 권한 위임 방식 (사용자가 직접 비밀번호를 제공하지 않아도 됨)
- 다양한 인증 플로우 존재
  - Authorization Code Flow (보안성이 높아 가장 많이 사용됨)
  - Implicit Flow (브라우저 기반, 보안이 취약해 현재는 잘 사용되지 않음)
  - Password Credentials Flow (ID/PW를 직접 입력하는 방식, 보안 취약 가능성 있음)
  - Client Credentials Flow (서버-서버 인증)
## 장점
- 보안성이 높음
- 타사 서비스 연동 용이
- 확장성 높음
## 단점
- 구현이 복잡함
- OAuth 제공자의 정책에 의존
- API 요청 시 토큰 관리 필요